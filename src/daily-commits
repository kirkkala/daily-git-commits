#!/bin/bash

# daily-commits - A beautiful git commit history viewer
# https://github.com/kirkkala/daily-git-commits

# Color definitions (needed for help)
COLOR_RED=$(tput setaf 1)
COLOR_GREEN=$(tput setaf 2)
COLOR_YELLOW=$(tput setaf 3)
COLOR_BLUE=$(tput setaf 4)
COLOR_MAGENTA=$(tput setaf 5)
COLOR_RESET=$(tput sgr0)

# Configuration paths
CONFIG_DIR="${HOME}/.config/daily-git-commits"
ENV_FILE="${CONFIG_DIR}/.env"

# Allow override for testing or custom locations
if [[ -n "${DAILY_COMMITS_CONFIG_DIR}" ]]; then
  CONFIG_DIR="${DAILY_COMMITS_CONFIG_DIR}"
  ENV_FILE="${CONFIG_DIR}/.env"
fi

# Help function (defined early so it works without config)
show_help() {
  cat << EOF

${COLOR_GREEN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘              ðŸ“…  daily-commits - Usage Guide  âœ¨              â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${COLOR_RESET}

${COLOR_BLUE}DESCRIPTION${COLOR_RESET}
  A delightfully fancy tool that finds your git commits across all
  your projects and presents them in a beautiful report.

${COLOR_BLUE}USAGE${COLOR_RESET}
  ${COLOR_GREEN}daily-commits${COLOR_RESET} [DATE] [END_DATE]
  ${COLOR_GREEN}daily-commits${COLOR_RESET} [SHORTCUT]
  ${COLOR_GREEN}daily-commits${COLOR_RESET} --help

${COLOR_BLUE}OPTIONS${COLOR_RESET}
  ${COLOR_YELLOW}--help, -h, help${COLOR_RESET}     Show this help message

${COLOR_BLUE}SHORTCUTS${COLOR_RESET} (for the lazy typist ðŸ˜Ž)
  ${COLOR_YELLOW}(no args)${COLOR_RESET}            Today's commits
  ${COLOR_YELLOW}yd, yesterday${COLOR_RESET}        Yesterday's commits
  ${COLOR_YELLOW}w, week${COLOR_RESET}              Last 7 days
  ${COLOR_YELLOW}3d, 3day, 3days${COLOR_RESET}      Last 3 days (any number works!)
  ${COLOR_YELLOW}7d${COLOR_RESET}                   Last 7 days
  ${COLOR_YELLOW}30d${COLOR_RESET}                  Last 30 days (you overachiever!)

${COLOR_BLUE}DATE FORMATS${COLOR_RESET}
  ${COLOR_YELLOW}YYYY-MM-DD${COLOR_RESET}           Single date (e.g., 2025-11-19)
  ${COLOR_YELLOW}YYYY-MM-DD YYYY-MM-DD${COLOR_RESET} Date range

${COLOR_BLUE}EXAMPLES${COLOR_RESET}
  ${COLOR_GREEN}daily-commits${COLOR_RESET}
    â†’ Show today's commits

  ${COLOR_GREEN}daily-commits yd${COLOR_RESET}
    â†’ Show yesterday's commits

  ${COLOR_GREEN}daily-commits 5d${COLOR_RESET}
    â†’ Show commits from last 5 days

  ${COLOR_GREEN}daily-commits 2025-11-01${COLOR_RESET}
    â†’ Show commits from November 1st, 2025

  ${COLOR_GREEN}daily-commits 2025-11-01 2025-11-15${COLOR_RESET}
    â†’ Show commits from November 1-15, 2025

${COLOR_BLUE}CONFIGURATION${COLOR_RESET}
  Config file: ${COLOR_YELLOW}${CONFIG_DIR}/.env${COLOR_RESET}
  Edit to change: author name, projects directory, search depth

${COLOR_BLUE}MORE INFO${COLOR_RESET}
  ${COLOR_MAGENTA}https://github.com/kirkkala/daily-git-commits${COLOR_RESET}

EOF
  exit 0
}

# Check for help flag BEFORE loading config
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]] || [[ "$1" == "help" ]]; then
  show_help
fi

# Load configuration
if [[ -f "$ENV_FILE" ]]; then
  # Safely parse the .env file without executing arbitrary code
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]] && continue

    # Extract key=value pairs
    if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"

      # Remove surrounding quotes if present
      value="${value%\"}"
      value="${value#\"}"
      value="${value%\'}"
      value="${value#\'}"

      # Only accept known configuration keys
      case "$key" in
        AUTHOR)
          author="$value"
          ;;
        LOCAL_PROJECTS_DIRECTORY_ROOT)
          local_projects_directory_root="$value"
          ;;
        MAXDEPTH)
          maxdepth="$value"
          ;;
      esac
    fi
  done < "$ENV_FILE"

  # Set defaults if not specified
  maxdepth="${maxdepth:-3}"

  # Validate required configuration values
  if [[ -z "$author" ]]; then
    echo " "
    echo "${COLOR_RED}âš ï¸  Error: AUTHOR not set in configuration file${COLOR_RESET}"
    echo "   Please check: $ENV_FILE"
    echo " "
    exit 1
  fi

  if [[ -z "$local_projects_directory_root" ]]; then
    echo " "
    echo "${COLOR_RED}âš ï¸  Error: LOCAL_PROJECTS_DIRECTORY_ROOT not set in configuration file${COLOR_RESET}"
    echo "   Please check: $ENV_FILE"
    echo " "
    exit 1
  fi

  # Validate maxdepth is a positive integer (security check)
  if ! [[ "$maxdepth" =~ ^[0-9]+$ ]] || [[ "$maxdepth" -eq 0 ]]; then
    echo " "
    echo "${COLOR_RED}âš ï¸  Error: MAXDEPTH must be a positive integer${COLOR_RESET}"
    echo "   Current value: '$maxdepth'"
    echo "   Please check: $ENV_FILE"
    echo " "
    exit 1
  fi

  # Warn if projects directory points to sensitive system directories
  case "$local_projects_directory_root" in
    /etc*|/sys*|/proc*|/var*|/bin*|/sbin*|/usr/bin*|/usr/sbin*|/boot*)
      echo " "
      echo "${COLOR_YELLOW}âš ï¸  Warning: Your projects directory points to a system directory:${COLOR_RESET}"
      echo "   $local_projects_directory_root"
      echo " "
      echo "   This may be unsafe and slow. Consider using a user directory instead."
      echo " "
      read -p "   Continue anyway? (y/N) " -n 1 -r
      echo " "
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
      fi
      ;;
  esac
else
  echo " "
  echo "âš ï¸  Configuration file not found at: $ENV_FILE"
  echo " "
  echo "   It looks like daily-commits isn't configured yet!"
  echo " "
  echo "   Quick setup:"
  echo "   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo "   1. Create the config directory:"
  echo "      mkdir -p \"${CONFIG_DIR}\""
  echo " "
  echo "   2. Copy the example config:"
  echo "      cp \"$(dirname "${BASH_SOURCE[0]}")/../env.example\" \"${ENV_FILE}\""
  echo " "
  echo "   3. Edit the config with your details:"
  echo "      vi \"${ENV_FILE}\""
  echo "      (or use your favorite editor)"
  echo "   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo " "
  exit 1
fi

# Validate projects directory
if [[ ! -d $local_projects_directory_root ]]; then
  echo -e "${COLOR_RED}#################\nDIRECTORY DOES NOT EXIST: ${local_projects_directory_root}${COLOR_RESET}\n
Check the LOCAL_PROJECTS_DIRECTORY_ROOT variable in: ${ENV_FILE}\n"
  exit 1
fi

from="$1"
to="$2"

# Define shorthand patterns in one place for maintainability
YESTERDAY_SHORTCUTS=("yd" "yesterday")
WEEK_SHORTCUTS=("w" "week")
DAYS_PATTERN='^([0-9]+)(d|day|days)$'

# Function to check if value is in array
in_array() {
  local value="$1"
  shift
  local item
  for item in "$@"; do
    [[ "$item" == "$value" ]] && return 0
  done
  return 1
}

# Check if first parameter is a shorthand and validate no second argument
is_shorthand=false
if in_array "$from" "${YESTERDAY_SHORTCUTS[@]}" "${WEEK_SHORTCUTS[@]}" || [[ "$from" =~ $DAYS_PATTERN ]]; then
  is_shorthand=true
  if [[ -n "$to" ]]; then
    echo -e "\n${COLOR_RED}âš ï¸  Shorthand parameter '${from}' cannot be combined with a second argument!${COLOR_RESET}"
    echo -e "   Usage: ${COLOR_GREEN}daily-commits ${from}${COLOR_RESET}\n"
    exit 1
  fi
fi

# Handle shorthand date parameters
case "$from" in
  yd|yesterday)
    from=$(date -j -v -1d +'%Y-%m-%d')
    to="$from"
    ;;
  w|week)
    from=$(date -j -v -6d +'%Y-%m-%d')
    to=$(date +'%Y-%m-%d')
    ;;
  "")
    # No arguments passed, default from and to date on current day
    from=$(date +'%Y-%m-%d')
    to="$from"
    ;;
  *)
    # Check if parameter matches pattern like "3d", "5days", "10day"
    if [[ "$from" =~ $DAYS_PATTERN ]]; then
      num_days="${BASH_REMATCH[1]}"
      # Subtract 1 because the range includes both start and end dates
      # e.g., "3d" means 3 days total (today + 2 days back)
      days_back=$((num_days - 1))
      from=$(date -j -v -${days_back}d +'%Y-%m-%d')
      to=$(date +'%Y-%m-%d')
    elif [[ $# -eq 1 ]]; then
      # Regular date parameter - only one date argument, use it for both from and to (single day)
      to="$from"
    fi
    ;;
esac

# Validate that dates are not in the future
current_date=$(date +'%Y-%m-%d')
from_timestamp=$(date -j -f "%Y-%m-%d" "$from" +%s 2>/dev/null)
to_timestamp=$(date -j -f "%Y-%m-%d" "$to" +%s 2>/dev/null)
current_timestamp=$(date -j -f "%Y-%m-%d" "$current_date" +%s)

# Check if date parsing failed
if [[ -z "$from_timestamp" ]] || [[ -z "$to_timestamp" ]]; then
  echo -e "\n${COLOR_RED}âš ï¸  Invalid date format!${COLOR_RESET}"
  echo -e "   Expected format: ${COLOR_YELLOW}YYYY-MM-DD${COLOR_RESET}"
  echo -e "   Run ${COLOR_GREEN}daily-commits --help${COLOR_RESET} for usage examples.\n"
  exit 1
fi

if [[ $from_timestamp -gt $current_timestamp ]] || [[ $to_timestamp -gt $current_timestamp ]]; then
  future_messages=(
    "ðŸš—âš¡ Great Scott! You're trying to access commits from the future!\n   Even Doc Brown's DeLorean can't help with that one!"
    "ðŸ”® Nice try, time traveler! We don't have a flux capacitor installed.\n   Try a date that's actually happened... in this timeline at least."
    "â° Whoa, McFly! Those commits haven't been written yet!\n   Roads? Where we're going, we don't need roads... but we DO need past dates!"
    "ðŸŒŒ Houston, we have a temporal problem!\n   You're requesting commits from a date that exists only in the space-time continuum of 'Not Yet'."
    "ðŸŽ° Plot twist: The commits you seek are still in the future!\n   Unless you're a Time Lord, please stick to dates from the past."
    "ðŸ¦– Fun fact: Git wasn't designed for time travel!\n   (Though that would make rebasing way cooler)"
  )

  random_index=$((RANDOM % ${#future_messages[@]}))
  echo -e "\n${COLOR_YELLOW}${future_messages[$random_index]}${COLOR_RESET}\n"
  exit 1
fi

end=$(date -j -v +1d -f "%Y-%m-%d" "$to" +%Y-%m-%d)

# Function to calculate display width of text with emojis
function getDisplayWidth() {
  local text="$1"
  # Use wc -m to get character count, then adjust for emoji display width
  local char_count=$(echo -n "$text" | wc -m | tr -d ' ')
  
  # Count our specific emojis
  local calendar_emoji_count=$(echo -n "$text" | grep -o 'ðŸ“…' | wc -l | tr -d ' ')
  local developer_emoji_count=$(echo -n "$text" | grep -o 'ðŸ‘¨â€ðŸ’»' | wc -l | tr -d ' ')
  
  # ðŸ“… displays as 2 characters but wc -m counts as 1, so add 1
  # ðŸ‘¨â€ðŸ’» is a compound emoji that displays as 2 but wc -m counts as 3 (man+zwj+computer), so subtract 1
  local display_len=$((char_count + calendar_emoji_count - developer_emoji_count))
  echo $display_len
}

function getCommitsPerDate() {
  local temp_file=$(mktemp) || {
    echo "${COLOR_RED}Error: Failed to create temporary file${COLOR_RESET}" >&2
    return 1
  }
  local found_commits=false
  
  find "$local_projects_directory_root" -name .git -type d -prune -maxdepth "$maxdepth" -exec dirname {} \; | while read line; do
    logs=$(git -C "${line}" log --reverse --decorate --pretty=format:"%ai | %s%d [%an]" --abbrev-commit --all --author="$author" | grep "$from")
    if [ "$logs" != "" ]; then
      # Extract just the project name from the full path
      project_name=$(basename "${line}")
      echo -e "\n${COLOR_BLUE}ðŸ“‚ ${project_name}${COLOR_RESET}"
      echo -e "${COLOR_MAGENTA}   â””â”€ ${line}${COLOR_RESET}"
      
      # Process each commit log entry
      echo "${logs//\ \+0300/}" | while IFS= read -r commit_line; do
        if [ -n "$commit_line" ]; then
          # Extract time, message, and branch info
          time_part=$(echo "$commit_line" | cut -d'|' -f1 | xargs)
          message_and_branch=$(echo "$commit_line" | cut -d'|' -f2- | xargs)
          
          # Extract just the time (HH:MM:SS)
          time_only=$(echo "$time_part" | cut -d' ' -f2)
          
          echo -e "   ${COLOR_GREEN}ðŸ•’ ${time_only}${COLOR_RESET} ${COLOR_YELLOW}ðŸ’» ${message_and_branch}${COLOR_RESET}"
        fi
      done
      echo "found" > "$temp_file"
    fi
  done
  
  # Check if no commits were found and display a funny message
  if [ ! -f "$temp_file" ] || [ ! -s "$temp_file" ]; then
    funny_messages=(
      "ðŸ¦— *crickets chirping* - Looks like the code took a vacation day!"
      "ðŸ–ï¸ Even developers need beach days! No commits found."
      "ðŸŽ¯ Achievement Unlocked: Master of Procrastination!"
      "ðŸ¦¥ Embracing the sloth lifestyle - zero commits detected!"
      "ðŸ• Probably too busy deciding between pizza toppings to commit code."
      "ðŸ›Œ The code is sleeping peacefully. Do not disturb."
      "ðŸŽ® Plot twist: Spent the day debugging... someone else's code!"
      "ðŸ¦¸â€â™‚ï¸ Even superheroes have secret identity days (no commits)."
      "ðŸŽª The commits ran away to join the circus!"
      "ðŸ” Commits are playing hide and seek... and winning!"
    )
    
    # Select a random funny message
    random_index=$((RANDOM % ${#funny_messages[@]}))
    echo -e "\n   ${COLOR_YELLOW}${funny_messages[$random_index]}${COLOR_RESET}"
  fi
  
  # Clean up temp file
  [ -f "$temp_file" ] && rm "$temp_file"
}

while [ "$from" != "$end" ]; do
  # Format the date nicely
  formatted_date=$(date -j -f "%Y-%m-%d" "$from" "+%B %d, %Y")
  day_of_week=$(date -j -f "%Y-%m-%d" "$from" "+%A")
  
  # Create the content lines
  date_line="ðŸ“… ${day_of_week}, ${formatted_date}"
  author_line="ðŸ‘¨â€ðŸ’» ${author}'s coding adventures"
  
  # Calculate the display width of each line (accounting for emoji display width)
  date_display_len=$(getDisplayWidth "$date_line")
  author_display_len=$(getDisplayWidth "$author_line")
  
  # Find the longest line and set minimum width
  max_content_len=$((date_display_len > author_display_len ? date_display_len : author_display_len))
  min_width=60
  content_width=$((max_content_len > min_width ? max_content_len : min_width))
  
  # Total box width includes borders and padding
  box_width=$((content_width + 4))  # 2 for borders + 2 for minimum padding
  
  # Create dynamic borders
  border_line=""
  for ((i=0; i<box_width-2; i++)); do
    border_line+="â•"
  done
  
  # Calculate padding for centering (ensuring both sides are equal)
  date_total_padding=$((box_width - date_display_len - 2))
  date_padding=$((date_total_padding / 2))
  date_right_padding=$((date_total_padding - date_padding))
  
  author_total_padding=$((box_width - author_display_len - 2))
  author_padding=$((author_total_padding / 2))
  author_right_padding=$((author_total_padding - author_padding))
  
  echo -e "\n\n${COLOR_GREEN}â•”${border_line}â•—"
  printf "${COLOR_GREEN}â•‘%*s%s%*sâ•‘${COLOR_RESET}\n" $date_padding "" "$date_line" $date_right_padding ""
  printf "${COLOR_GREEN}â•‘%*s%s%*sâ•‘${COLOR_RESET}\n" $author_padding "" "$author_line" $author_right_padding ""
  echo -e "${COLOR_GREEN}â•š${border_line}â•${COLOR_RESET}"
  
  getCommitsPerDate "$from" "$author"
  
  # Add a nice separator line if there are more days to process
  next_date=$(date -j -v +1d -f "%Y-%m-%d" "$from" +%Y-%m-%d)
  if [ "$next_date" != "$end" ]; then
    echo -e "\n${COLOR_BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${COLOR_RESET}"
  fi
  
  from=$next_date
done

